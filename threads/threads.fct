# Thread specification for ISO metric, UTS/SAE, and NPT pipe threads.
#
# All standards use the same 60° V-profile. The `taper` field controls
# diameter growth per unit length (`0` for straight, `1/16` for NPT).
# The `tolerance` field is a radial clearance applied to both inside and
# outside threads — 0.2 mm by default, suitable for FDM 3D printing.
struct Thread {
    Length pitch;
    Length major_diameter;
    Number taper;
    Length tolerance;
}

# ISO metric coarse pitch table: [diameter, pitch]
var METRIC_COARSE = [
    [2, 0.4],   [2.5, 0.45], [3, 0.5],   [3.5, 0.6], [4, 0.7],   [5, 0.8],
    [6, 1.0],   [8, 1.25],   [10, 1.5],  [12, 1.75], [14, 2.0],  [16, 2.0],
    [18, 2.5],  [20, 2.5],   [22, 2.5],  [24, 3.0],  [27, 3.0],  [30, 3.5],
    [33, 3.5],  [36, 4.0],   [39, 4.0],  [42, 4.5],  [45, 4.5],  [48, 5.0],
    [52, 5.0],  [56, 5.5],   [60, 5.5],  [64, 6.0],  [68, 6.0]
];

# Returns the ISO coarse pitch for a given metric diameter.
Length MetricCoarsePitch(Length d) {
    var v = Number(d);
    var matches = for i [0:<Size(METRIC_COARSE)] {
        if METRIC_COARSE[i][0] == v {
            yield METRIC_COARSE[i][1];
        };
    };
    assert Size(matches) > 0, "unsupported metric coarse diameter";
    return matches[0] * 1 mm;
}

# Imperial thread table: [size, pitch_in, diameter_in, taper]
var IMPERIAL = [
    # SAE UNC (coarse)
    ["#4-40",    1/40,   0.112,   0],
    ["#6-32",    1/32,   0.138,   0],
    ["#8-32",    1/32,   0.164,   0],
    ["#10-24",   1/24,   0.190,   0],
    ["1/4-20",   1/20,   1/4,     0],
    ["5/16-18",  1/18,   5/16,    0],
    ["3/8-16",   1/16,   3/8,     0],
    ["7/16-14",  1/14,   7/16,    0],
    ["1/2-13",   1/13,   1/2,     0],
    ["5/8-11",   1/11,   5/8,     0],
    ["3/4-10",   1/10,   3/4,     0],
    # SAE UNF (fine)
    ["#4-48",    1/48,   0.112,   0],
    ["#6-40",    1/40,   0.138,   0],
    ["#8-36",    1/36,   0.164,   0],
    ["#10-32",   1/32,   0.190,   0],
    ["1/4-28",   1/28,   1/4,     0],
    ["5/16-24",  1/24,   5/16,    0],
    ["3/8-24",   1/24,   3/8,     0],
    ["7/16-20",  1/20,   7/16,    0],
    ["1/2-20",   1/20,   1/2,     0],
    ["5/8-18",   1/18,   5/8,     0],
    ["3/4-16",   1/16,   3/4,     0],
    # NPT (diameter is pipe OD, not nominal pipe size)
    ["1/8-npt",  1/27,   0.405,   1/16],
    ["1/4-npt",  1/18,   0.540,   1/16],
    ["3/8-npt",  1/18,   0.675,   1/16],
    ["1/2-npt",  1/14,   0.840,   1/16],
    ["3/4-npt",  1/14,   1.050,   1/16],
    ["1-npt",    2/23,   1.315,   1/16]
];

# Looks up an imperial thread by size string.
Thread ImperialThread(String size) {
    var matches = for i [0:<Size(IMPERIAL)] {
        if IMPERIAL[i][0] == size {
            yield IMPERIAL[i];
        };
    };
    assert Size(matches) > 0, "unsupported thread size";
    var row = matches[0];
    return Thread {
        pitch: row[1] * 1 in,
        major_diameter: row[2] * 1 in,
        taper: row[3],
        tolerance: 0.1 mm
    };
}

# Creates a `Thread` from a standard size name.
#
# **Metric coarse (ISO):** `"m2"` through `"m68"` — all standard ISO diameters.
#
# **Metric fine (ISO):** `"m<d>x<p>"` — any diameter and pitch,
# e.g. `"m8x1"`, `"m3x0.35"`, `"m30x2"`.
#
# **SAE UNC (coarse):** `"#4-40"`, `"#6-32"`, `"#8-32"`, `"#10-24"`,
# `"1/4-20"`, `"5/16-18"`, `"3/8-16"`, `"7/16-14"`, `"1/2-13"`, `"5/8-11"`, `"3/4-10"`
#
# **SAE UNF (fine):** `"#4-48"`, `"#6-40"`, `"#8-36"`, `"#10-32"`,
# `"1/4-28"`, `"5/16-24"`, `"3/8-24"`, `"7/16-20"`, `"1/2-20"`, `"5/8-18"`, `"3/4-16"`
#
# **NPT:** `"1/8-npt"`, `"1/4-npt"`, `"3/8-npt"`, `"1/2-npt"`, `"3/4-npt"`, `"1-npt"`
Thread New(String size) {
    # --- Metric fine: m<diameter>x<pitch> ---
    var mfine = size.Match(`m(\d+\.?\d*)x([\d.]+)`);
    return if mfine == true {
        var d = Number(mfine[1]) * 1 mm;
        var p = Number(mfine[2]) * 1 mm;
        return Thread { pitch: p, major_diameter: d, taper: 0, tolerance: 0.1 mm };
    } else {
    # --- Metric coarse: m<diameter> ---
    var mcoarse = size.Match(`m(\d+\.?\d*)$`);
    return if mcoarse == true {
        var d = Number(mcoarse[1]) * 1 mm;
        return Thread { pitch: MetricCoarsePitch(d), major_diameter: d, taper: 0, tolerance: 0.1 mm };
    } else {
    # --- Imperial: SAE UNC, UNF, NPT ---
    return ImperialThread(size);
    };
    };
}

# Generates an external (outside) thread `Solid`.
#
# Uses a 60° V-profile with H/8 crest truncation and H/4 root truncation.
# When `taper > 0` (NPT), the polygon is built at the small-end radius and
# the extrusion scales to the large-end radius.
#
# Returns a `Solid` aligned along the Z axis from Z=0 to Z=`length`.
Solid Thread.Outside(Length length) {
    var pitch = self.pitch;
    var major_d = self.major_diameter;
    var taper = self.taper;
    var tol = self.tolerance;
    var turns = length / pitch;

    # Taper: diameter changes by length * taper over the full length
    var taper_d = length * taper;
    var d_small = major_d - taper_d / 2;
    var d_large = major_d + taper_d / 2;
    var taper_scale = if taper > 0 { return d_large / d_small; } else { return 1; };

    var H = pitch * Sqrt(3) / 2;
    # Shrink outside thread by tolerance so printed bolt fits
    var r_maj = d_small / 2 - tol;
    var r_min = r_maj - H * 0.625;

    # ISO angular half-widths (constant for all 60-deg threads):
    #   crest: (P/16) * 2π/P = π/8 = 22.5 deg
    #   root:  (3P/8) * 2π/P = 3π/4 = 135 deg
    var crest_half = 22.5 deg;
    var root_half = 135 deg;
    var gap = 360 deg - 2 * root_half;

    # Sample counts per polygon segment
    var n_flank = 10;
    var n_crest = 4;
    var n_root = 8;
    var n_total = n_flank * 2 + n_crest + n_root;

    # Build tooth polygon in polar coordinates: (r*cos(theta), r*sin(theta))
    # Segments: leading flank, crest arc, trailing flank, root arc
    var points = for i[0:<n_total] {
        var pt = if i < n_flank {
            # Leading flank: (r_min, -root_half) to (r_maj, -crest_half)
            var t = i / (n_flank - 1);
            var r = r_min + (r_maj - r_min) * t;
            var theta = (0 deg - root_half) + (root_half - crest_half) * t;
            return Point2d(r * Cos(theta), r * Sin(theta));
        } else if i < n_flank + n_crest {
            # Crest arc at r_maj: from -crest_half to +crest_half
            var j = i - n_flank;
            var t = j / (n_crest - 1);
            var theta = (0 deg - crest_half) + 2 * crest_half * t;
            return Point2d(r_maj * Cos(theta), r_maj * Sin(theta));
        } else if i < n_flank * 2 + n_crest {
            # Trailing flank: (r_maj, +crest_half) to (r_min, +root_half)
            var j = i - n_flank - n_crest;
            var t = j / (n_flank - 1);
            var r = r_maj + (r_min - r_maj) * t;
            var theta = crest_half + (root_half - crest_half) * t;
            return Point2d(r * Cos(theta), r * Sin(theta));
        } else {
            # Root arc at r_min: from +root_half through 180 deg to -root_half (90 deg span)
            var j = i - n_flank * 2 - n_crest;
            var t = j / (n_root - 1);
            var theta = root_half + gap * t;
            return Point2d(r_min * Cos(theta), r_min * Sin(theta));
        };
        yield pt;
    };

    var tooth = Polygon(points);
    return tooth.Extrude(length, turns * 80, turns * 360 deg, taper_scale, taper_scale);
}

# Generates an internal (inside) thread `Solid`.
#
# Adds clearance tolerance and uses a sharp V-profile. The radii are shifted
# outward so a bolt fits with clearance. When `taper > 0` (NPT), applies
# taper scaling during extrusion.
#
# Returns a `Solid` aligned along the Z axis from Z=0 to Z=`length`.
# Subtract this from a nut body to create internal threads.
Solid Thread.Inside(Length length) {
    var pitch = self.pitch;
    var major_d = self.major_diameter;
    var taper = self.taper;
    var turns = length / pitch;

    # Taper: diameter changes by length * taper over the full length
    var taper_d = length * taper;
    var d_small = major_d - taper_d / 2;
    var d_large = major_d + taper_d / 2;
    var taper_scale = if taper > 0 { return d_large / d_small; } else { return 1; };

    var H = pitch * Sqrt(3) / 2;
    # Expand inside thread by tolerance so printed nut fits
    var tol = self.tolerance;
    var r_maj = d_small / 2 + tol;
    var r_min = d_small / 2 - H * 0.625 + tol;

    # Sharp V-profile: minimal crest/root flats
    var crest_half = 5 deg;
    var root_half = 170 deg;
    var gap = 360 deg - 2 * root_half;

    # Sample counts per polygon segment
    var n_flank = 10;
    var n_crest = 2;
    var n_root = 2;
    var n_total = n_flank * 2 + n_crest + n_root;

    # Build tooth polygon in polar coordinates
    # Segments: leading flank, crest arc, trailing flank, root arc
    var points = for i[0:<n_total] {
        var pt = if i < n_flank {
            # Leading flank: (r_min, -root_half) to (r_maj, -crest_half)
            var t = i / (n_flank - 1);
            var r = r_min + (r_maj - r_min) * t;
            var theta = (0 deg - root_half) + (root_half - crest_half) * t;
            return Point2d(r * Cos(theta), r * Sin(theta));
        } else if i < n_flank + n_crest {
            # Crest at r_maj: from -crest_half to +crest_half
            var j = i - n_flank;
            var t = j / (n_crest - 1);
            var theta = (0 deg - crest_half) + 2 * crest_half * t;
            return Point2d(r_maj * Cos(theta), r_maj * Sin(theta));
        } else if i < n_flank * 2 + n_crest {
            # Trailing flank: (r_maj, +crest_half) to (r_min, +root_half)
            var j = i - n_flank - n_crest;
            var t = j / (n_flank - 1);
            var r = r_maj + (r_min - r_maj) * t;
            var theta = crest_half + (root_half - crest_half) * t;
            return Point2d(r * Cos(theta), r * Sin(theta));
        } else {
            # Root at r_min: from +root_half to -root_half
            var j = i - n_flank * 2 - n_crest;
            var t = j / (n_root - 1);
            var theta = root_half + gap * t;
            return Point2d(r_min * Cos(theta), r_min * Sin(theta));
        };
        yield pt;
    };

    var tooth = Polygon(points);
    return tooth.Extrude(length, turns * 80, turns * 360 deg, taper_scale, taper_scale);
}
